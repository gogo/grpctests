// Code generated by protoc-gen-gogo.
// source: grpc.proto
// DO NOT EDIT!

/*
	Package grpc is a generated protocol buffer package.

	It is generated from these files:
		grpc.proto

	It has these top-level messages:
		MyRequest
		MyResponse
		MyMsg
		MyMsg2
*/
package grpc

import proto "github.com/gogo/protobuf/proto"
import test "github.com/gogo/protobuf/test"

import (
	context "golang.org/x/net/context"
	grpc1 "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc1.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type MyRequest struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyRequest) Reset()         { *m = MyRequest{} }
func (m *MyRequest) String() string { return proto.CompactTextString(m) }
func (*MyRequest) ProtoMessage()    {}

type MyResponse struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyResponse) Reset()         { *m = MyResponse{} }
func (m *MyResponse) String() string { return proto.CompactTextString(m) }
func (*MyResponse) ProtoMessage()    {}

type MyMsg struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyMsg) Reset()         { *m = MyMsg{} }
func (m *MyMsg) String() string { return proto.CompactTextString(m) }
func (*MyMsg) ProtoMessage()    {}

type MyMsg2 struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyMsg2) Reset()         { *m = MyMsg2{} }
func (m *MyMsg2) String() string { return proto.CompactTextString(m) }
func (*MyMsg2) ProtoMessage()    {}

func init() {
}

// Client API for MyTest service

type MyTestClient interface {
	UnaryCall(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (*MyResponse, error)
	// This RPC streams from the server only.
	Downstream(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyTest_DownstreamClient, error)
	// This RPC streams from the client.
	Upstream(ctx context.Context, opts ...grpc1.CallOption) (MyTest_UpstreamClient, error)
	// This one streams in both directions.
	Bidi(ctx context.Context, opts ...grpc1.CallOption) (MyTest_BidiClient, error)
}

type myTestClient struct {
	cc *grpc1.ClientConn
}

func NewMyTestClient(cc *grpc1.ClientConn) MyTestClient {
	return &myTestClient{cc}
}

func (c *myTestClient) UnaryCall(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (*MyResponse, error) {
	out := new(MyResponse)
	err := grpc1.Invoke(ctx, "/grpc.MyTest/UnaryCall", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myTestClient) Downstream(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyTest_DownstreamClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[0], c.cc, "/grpc.MyTest/Downstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestDownstreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyTest_DownstreamClient interface {
	Recv() (*MyMsg, error)
	grpc1.ClientStream
}

type myTestDownstreamClient struct {
	grpc1.ClientStream
}

func (x *myTestDownstreamClient) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myTestClient) Upstream(ctx context.Context, opts ...grpc1.CallOption) (MyTest_UpstreamClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[1], c.cc, "/grpc.MyTest/Upstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestUpstreamClient{stream}
	return x, nil
}

type MyTest_UpstreamClient interface {
	Send(*MyMsg) error
	CloseAndRecv() (*MyResponse, error)
	grpc1.ClientStream
}

type myTestUpstreamClient struct {
	grpc1.ClientStream
}

func (x *myTestUpstreamClient) Send(m *MyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *myTestUpstreamClient) CloseAndRecv() (*MyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(MyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myTestClient) Bidi(ctx context.Context, opts ...grpc1.CallOption) (MyTest_BidiClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[2], c.cc, "/grpc.MyTest/Bidi", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestBidiClient{stream}
	return x, nil
}

type MyTest_BidiClient interface {
	Send(*MyMsg) error
	Recv() (*MyMsg2, error)
	grpc1.ClientStream
}

type myTestBidiClient struct {
	grpc1.ClientStream
}

func (x *myTestBidiClient) Send(m *MyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *myTestBidiClient) Recv() (*MyMsg2, error) {
	m := new(MyMsg2)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MyTest service

type MyTestServer interface {
	UnaryCall(context.Context, *MyRequest) (*MyResponse, error)
	// This RPC streams from the server only.
	Downstream(*MyRequest, MyTest_DownstreamServer) error
	// This RPC streams from the client.
	Upstream(MyTest_UpstreamServer) error
	// This one streams in both directions.
	Bidi(MyTest_BidiServer) error
}

func RegisterMyTestServer(s *grpc1.Server, srv MyTestServer) {
	s.RegisterService(&_MyTest_serviceDesc, srv)
}

func _MyTest_UnaryCall_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(MyRequest)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MyTestServer).UnaryCall(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MyTest_Downstream_Handler(srv interface{}, stream grpc1.ServerStream) error {
	m := new(MyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyTestServer).Downstream(m, &myTestDownstreamServer{stream})
}

type MyTest_DownstreamServer interface {
	Send(*MyMsg) error
	grpc1.ServerStream
}

type myTestDownstreamServer struct {
	grpc1.ServerStream
}

func (x *myTestDownstreamServer) Send(m *MyMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _MyTest_Upstream_Handler(srv interface{}, stream grpc1.ServerStream) error {
	return srv.(MyTestServer).Upstream(&myTestUpstreamServer{stream})
}

type MyTest_UpstreamServer interface {
	SendAndClose(*MyResponse) error
	Recv() (*MyMsg, error)
	grpc1.ServerStream
}

type myTestUpstreamServer struct {
	grpc1.ServerStream
}

func (x *myTestUpstreamServer) SendAndClose(m *MyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *myTestUpstreamServer) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MyTest_Bidi_Handler(srv interface{}, stream grpc1.ServerStream) error {
	return srv.(MyTestServer).Bidi(&myTestBidiServer{stream})
}

type MyTest_BidiServer interface {
	Send(*MyMsg2) error
	Recv() (*MyMsg, error)
	grpc1.ServerStream
}

type myTestBidiServer struct {
	grpc1.ServerStream
}

func (x *myTestBidiServer) Send(m *MyMsg2) error {
	return x.ServerStream.SendMsg(m)
}

func (x *myTestBidiServer) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MyTest_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "grpc.MyTest",
	HandlerType: (*MyTestServer)(nil),
	Methods: []grpc1.MethodDesc{
		{
			MethodName: "UnaryCall",
			Handler:    _MyTest_UnaryCall_Handler,
		},
	},
	Streams: []grpc1.StreamDesc{
		{
			StreamName:    "Downstream",
			Handler:       _MyTest_Downstream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Upstream",
			Handler:       _MyTest_Upstream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Bidi",
			Handler:       _MyTest_Bidi_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

// Client API for MyBench service

type MyBenchClient interface {
	Down(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyBench_DownClient, error)
}

type myBenchClient struct {
	cc *grpc1.ClientConn
}

func NewMyBenchClient(cc *grpc1.ClientConn) MyBenchClient {
	return &myBenchClient{cc}
}

func (c *myBenchClient) Down(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyBench_DownClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyBench_serviceDesc.Streams[0], c.cc, "/grpc.MyBench/Down", opts...)
	if err != nil {
		return nil, err
	}
	x := &myBenchDownClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyBench_DownClient interface {
	Recv() (*test.NinOptStruct, error)
	grpc1.ClientStream
}

type myBenchDownClient struct {
	grpc1.ClientStream
}

func (x *myBenchDownClient) Recv() (*test.NinOptStruct, error) {
	m := new(test.NinOptStruct)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MyBench service

type MyBenchServer interface {
	Down(*MyRequest, MyBench_DownServer) error
}

func RegisterMyBenchServer(s *grpc1.Server, srv MyBenchServer) {
	s.RegisterService(&_MyBench_serviceDesc, srv)
}

func _MyBench_Down_Handler(srv interface{}, stream grpc1.ServerStream) error {
	m := new(MyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyBenchServer).Down(m, &myBenchDownServer{stream})
}

type MyBench_DownServer interface {
	Send(*test.NinOptStruct) error
	grpc1.ServerStream
}

type myBenchDownServer struct {
	grpc1.ServerStream
}

func (x *myBenchDownServer) Send(m *test.NinOptStruct) error {
	return x.ServerStream.SendMsg(m)
}

var _MyBench_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "grpc.MyBench",
	HandlerType: (*MyBenchServer)(nil),
	Methods:     []grpc1.MethodDesc{},
	Streams: []grpc1.StreamDesc{
		{
			StreamName:    "Down",
			Handler:       _MyBench_Down_Handler,
			ServerStreams: true,
		},
	},
}
