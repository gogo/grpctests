// Code generated by protoc-gen-gogo.
// source: grpc.proto
// DO NOT EDIT!

/*
	Package grpc is a generated protocol buffer package.

	It is generated from these files:
		grpc.proto

	It has these top-level messages:
		MyRequest
		MyResponse
		MyMsg
		MyMsg2
*/
package grpc

import proto "github.com/gogo/protobuf/proto"
import test "github.com/gogo/protobuf/test"

import net_http "net/http"
import io_ioutil "io/ioutil"
import encoding_json "encoding/json"
import io "io"
import net "net"
import golang_org_x_net_context "golang.org/x/net/context"

import (
	context "golang.org/x/net/context"
	grpc1 "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc1.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type MyRequest struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyRequest) Reset()         { *m = MyRequest{} }
func (m *MyRequest) String() string { return proto.CompactTextString(m) }
func (*MyRequest) ProtoMessage()    {}

type MyResponse struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyResponse) Reset()         { *m = MyResponse{} }
func (m *MyResponse) String() string { return proto.CompactTextString(m) }
func (*MyResponse) ProtoMessage()    {}

type MyMsg struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyMsg) Reset()         { *m = MyMsg{} }
func (m *MyMsg) String() string { return proto.CompactTextString(m) }
func (*MyMsg) ProtoMessage()    {}

type MyMsg2 struct {
	Value int64 `protobuf:"varint,1,opt,proto3" json:"Value,omitempty"`
}

func (m *MyMsg2) Reset()         { *m = MyMsg2{} }
func (m *MyMsg2) String() string { return proto.CompactTextString(m) }
func (*MyMsg2) ProtoMessage()    {}

func init() {
}

type htmlMyTest struct {
	client   MyTestClient
	stringer func(interface{}) ([]byte, error)
	prefix   string
	port     string
}

func NewHTMLMyTestServer(prefix string, client MyTestClient, stringer func(interface{}) ([]byte, error)) *htmlMyTest {
	if stringer == nil {
		stringer = encoding_json.Marshal
	}
	return &htmlMyTest{client, stringer, prefix, ":8080"}
}
func (this *htmlMyTest) Serve(addr string) error {
	net_http.HandleFunc(this.prefix+"/UnaryCall", this.UnaryCall)
	net_http.HandleFunc(this.prefix+"/Downstream", this.Downstream)
	net_http.HandleFunc(this.prefix+"/Upstream", this.Upstream)
	net_http.HandleFunc(this.prefix+"/Bidi", this.Bidi)
	_, port, err := net.SplitHostPort(addr)
	if err != nil {
		return err
	}
	this.port = port
	return net_http.ListenAndServe(addr, nil)
}
func (this *htmlMyTest) UnaryCall(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - UnaryCall</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/UnaryCall:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyRequest{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := this.client.UnaryCall(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Downstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Downstream</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Downstream:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyRequest{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	down, err := this.client.Downstream(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	for {
		reply, err := down.Recv()
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		out, err := this.stringer(reply)
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		w.Write(out)
	}
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Upstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Upstream</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Upstream:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyMsg{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	up, err := this.client.Upstream(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = up.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := up.CloseAndRecv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Bidi(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Bidi</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Bidi:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyMsg{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	bidi, err := this.client.Bidi(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = bidi.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := bidi.Recv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}

type htmlMyBench struct {
	client   MyBenchClient
	stringer func(interface{}) ([]byte, error)
	prefix   string
	port     string
}

func NewHTMLMyBenchServer(prefix string, client MyBenchClient, stringer func(interface{}) ([]byte, error)) *htmlMyBench {
	if stringer == nil {
		stringer = encoding_json.Marshal
	}
	return &htmlMyBench{client, stringer, prefix, ":8080"}
}
func (this *htmlMyBench) Serve(addr string) error {
	net_http.HandleFunc(this.prefix+"/Down", this.Down)
	_, port, err := net.SplitHostPort(addr)
	if err != nil {
		return err
	}
	this.port = port
	return net_http.ListenAndServe(addr, nil)
}
func (this *htmlMyBench) Down(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyBench - Down</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Down:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyBench(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyRequest{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	down, err := this.client.Down(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	for {
		reply, err := down.Recv()
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		out, err := this.stringer(reply)
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		w.Write(out)
	}
	w.Write([]byte("</html>"))
}

// Client API for MyTest service

type MyTestClient interface {
	UnaryCall(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (*MyResponse, error)
	// This RPC streams from the server only.
	Downstream(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyTest_DownstreamClient, error)
	// This RPC streams from the client.
	Upstream(ctx context.Context, opts ...grpc1.CallOption) (MyTest_UpstreamClient, error)
	// This one streams in both directions.
	Bidi(ctx context.Context, opts ...grpc1.CallOption) (MyTest_BidiClient, error)
}

type myTestClient struct {
	cc *grpc1.ClientConn
}

func NewMyTestClient(cc *grpc1.ClientConn) MyTestClient {
	return &myTestClient{cc}
}

func (c *myTestClient) UnaryCall(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (*MyResponse, error) {
	out := new(MyResponse)
	err := grpc1.Invoke(ctx, "/grpc.MyTest/UnaryCall", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myTestClient) Downstream(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyTest_DownstreamClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[0], c.cc, "/grpc.MyTest/Downstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestDownstreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyTest_DownstreamClient interface {
	Recv() (*MyMsg, error)
	grpc1.ClientStream
}

type myTestDownstreamClient struct {
	grpc1.ClientStream
}

func (x *myTestDownstreamClient) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myTestClient) Upstream(ctx context.Context, opts ...grpc1.CallOption) (MyTest_UpstreamClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[1], c.cc, "/grpc.MyTest/Upstream", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestUpstreamClient{stream}
	return x, nil
}

type MyTest_UpstreamClient interface {
	Send(*MyMsg) error
	CloseAndRecv() (*MyResponse, error)
	grpc1.ClientStream
}

type myTestUpstreamClient struct {
	grpc1.ClientStream
}

func (x *myTestUpstreamClient) Send(m *MyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *myTestUpstreamClient) CloseAndRecv() (*MyResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(MyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myTestClient) Bidi(ctx context.Context, opts ...grpc1.CallOption) (MyTest_BidiClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyTest_serviceDesc.Streams[2], c.cc, "/grpc.MyTest/Bidi", opts...)
	if err != nil {
		return nil, err
	}
	x := &myTestBidiClient{stream}
	return x, nil
}

type MyTest_BidiClient interface {
	Send(*MyMsg) error
	Recv() (*MyMsg2, error)
	grpc1.ClientStream
}

type myTestBidiClient struct {
	grpc1.ClientStream
}

func (x *myTestBidiClient) Send(m *MyMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *myTestBidiClient) Recv() (*MyMsg2, error) {
	m := new(MyMsg2)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MyTest service

type MyTestServer interface {
	UnaryCall(context.Context, *MyRequest) (*MyResponse, error)
	// This RPC streams from the server only.
	Downstream(*MyRequest, MyTest_DownstreamServer) error
	// This RPC streams from the client.
	Upstream(MyTest_UpstreamServer) error
	// This one streams in both directions.
	Bidi(MyTest_BidiServer) error
}

func RegisterMyTestServer(s *grpc1.Server, srv MyTestServer) {
	s.RegisterService(&_MyTest_serviceDesc, srv)
}

func _MyTest_UnaryCall_Handler(srv interface{}, ctx context.Context, buf []byte) (interface{}, error) {
	in := new(MyRequest)
	if err := proto.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MyTestServer).UnaryCall(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MyTest_Downstream_Handler(srv interface{}, stream grpc1.ServerStream) error {
	m := new(MyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyTestServer).Downstream(m, &myTestDownstreamServer{stream})
}

type MyTest_DownstreamServer interface {
	Send(*MyMsg) error
	grpc1.ServerStream
}

type myTestDownstreamServer struct {
	grpc1.ServerStream
}

func (x *myTestDownstreamServer) Send(m *MyMsg) error {
	return x.ServerStream.SendMsg(m)
}

func _MyTest_Upstream_Handler(srv interface{}, stream grpc1.ServerStream) error {
	return srv.(MyTestServer).Upstream(&myTestUpstreamServer{stream})
}

type MyTest_UpstreamServer interface {
	SendAndClose(*MyResponse) error
	Recv() (*MyMsg, error)
	grpc1.ServerStream
}

type myTestUpstreamServer struct {
	grpc1.ServerStream
}

func (x *myTestUpstreamServer) SendAndClose(m *MyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *myTestUpstreamServer) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MyTest_Bidi_Handler(srv interface{}, stream grpc1.ServerStream) error {
	return srv.(MyTestServer).Bidi(&myTestBidiServer{stream})
}

type MyTest_BidiServer interface {
	Send(*MyMsg2) error
	Recv() (*MyMsg, error)
	grpc1.ServerStream
}

type myTestBidiServer struct {
	grpc1.ServerStream
}

func (x *myTestBidiServer) Send(m *MyMsg2) error {
	return x.ServerStream.SendMsg(m)
}

func (x *myTestBidiServer) Recv() (*MyMsg, error) {
	m := new(MyMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MyTest_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "grpc.MyTest",
	HandlerType: (*MyTestServer)(nil),
	Methods: []grpc1.MethodDesc{
		{
			MethodName: "UnaryCall",
			Handler:    _MyTest_UnaryCall_Handler,
		},
	},
	Streams: []grpc1.StreamDesc{
		{
			StreamName:    "Downstream",
			Handler:       _MyTest_Downstream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Upstream",
			Handler:       _MyTest_Upstream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Bidi",
			Handler:       _MyTest_Bidi_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

// Client API for MyBench service

type MyBenchClient interface {
	Down(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyBench_DownClient, error)
}

type myBenchClient struct {
	cc *grpc1.ClientConn
}

func NewMyBenchClient(cc *grpc1.ClientConn) MyBenchClient {
	return &myBenchClient{cc}
}

func (c *myBenchClient) Down(ctx context.Context, in *MyRequest, opts ...grpc1.CallOption) (MyBench_DownClient, error) {
	stream, err := grpc1.NewClientStream(ctx, &_MyBench_serviceDesc.Streams[0], c.cc, "/grpc.MyBench/Down", opts...)
	if err != nil {
		return nil, err
	}
	x := &myBenchDownClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyBench_DownClient interface {
	Recv() (*test.NinOptStruct, error)
	grpc1.ClientStream
}

type myBenchDownClient struct {
	grpc1.ClientStream
}

func (x *myBenchDownClient) Recv() (*test.NinOptStruct, error) {
	m := new(test.NinOptStruct)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MyBench service

type MyBenchServer interface {
	Down(*MyRequest, MyBench_DownServer) error
}

func RegisterMyBenchServer(s *grpc1.Server, srv MyBenchServer) {
	s.RegisterService(&_MyBench_serviceDesc, srv)
}

func _MyBench_Down_Handler(srv interface{}, stream grpc1.ServerStream) error {
	m := new(MyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyBenchServer).Down(m, &myBenchDownServer{stream})
}

type MyBench_DownServer interface {
	Send(*test.NinOptStruct) error
	grpc1.ServerStream
}

type myBenchDownServer struct {
	grpc1.ServerStream
}

func (x *myBenchDownServer) Send(m *test.NinOptStruct) error {
	return x.ServerStream.SendMsg(m)
}

var _MyBench_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "grpc.MyBench",
	HandlerType: (*MyBenchServer)(nil),
	Methods:     []grpc1.MethodDesc{},
	Streams: []grpc1.StreamDesc{
		{
			StreamName:    "Down",
			Handler:       _MyBench_Down_Handler,
			ServerStreams: true,
		},
	},
}
